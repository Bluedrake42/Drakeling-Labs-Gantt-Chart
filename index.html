<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drakeling Labs Studios - Task Management</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden; /* Prevent body scroll, scrolling happens in container */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            /* Remove margin/padding from body, apply padding to main-content */
            display: flex;
            flex-direction: column;
            /* align-items: center; Remove this, let containers stretch */
        }

        /* Optional: Add a main content wrapper for padding */
        .main-content {
            padding: 10px 15px; /* Reduced vertical padding */
            display: flex;
            flex-direction: column;
            flex-grow: 1; /* Allow this area to grow */
            overflow: hidden; /* Prevent this wrapper from scrolling */
            height: 100%; /* Ensure it tries to take full height */
            box-sizing: border-box;
        }

        h1 {
            color: #bb86fc;
            margin-bottom: 2px; /* Reduced margin to bring subtitle closer */
            margin-top: 0; /* Remove default top margin */
            text-align: center;
            flex-shrink: 0; /* Prevent shrinking */
        }

        h2.subtitle {
            color: #aaa; /* Lighter color for subtitle */
            font-size: 1.1em;
            font-weight: normal;
            text-align: center;
            margin-top: 0;
            margin-bottom: 10px; /* Spacing below subtitle */
            flex-shrink: 0;
        }

        /* Tab Styles */
        .tab-container {
            display: flex;
            width: 100%; 
            margin-bottom: 10px; /* Reduced margin */
            align-items: center;
            background-color: #2a2a2a; 
            border-radius: 4px;
            padding: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            flex-shrink: 0; /* Prevent shrinking */
        }

        .tab-scroll-btn {
            background: none;
            border: none;
            color: #bb86fc;
            font-size: 1.5em;
            cursor: pointer;
            padding: 0 10px;
            line-height: 1;
        }

        .tab-scroll-btn:disabled {
            color: #555;
            cursor: not-allowed;
        }

        .tab-list-wrapper {
            flex-grow: 1;
            overflow: hidden;
            position: relative;
        }

        .tab-list {
            display: flex;
            white-space: nowrap;
            position: relative;
            transition: transform 0.3s ease;
        }

        .tab {
            padding: 6px 12px; /* Reduced padding */
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-right: 5px;
            color: #aaa;
            transition: color 0.3s ease, border-color 0.3s ease;
            flex-shrink: 0; /* Prevent tabs from shrinking */
        }

        .tab:hover {
            color: #e0e0e0;
        }

        .tab.active {
            color: #bb86fc;
            border-bottom-color: #bb86fc;
            font-weight: bold;
        }

        .gantt-controls {
            margin-bottom: 10px; /* Reduced margin */
            display: flex;
            align-items: center;
            gap: 8px; /* Reduced gap */
        }

        .gantt-controls button {
            background-color: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #555;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .gantt-controls button:hover {
            background-color: #4a4a4a;
        }

        .gantt-controls button:disabled {
            background-color: #2a2a2a;
            color: #666;
            cursor: not-allowed;
            border-color: #444;
        }

        .gantt-controls span {
            font-weight: bold;
            color: #bb86fc;
            min-width: 100px; /* Ensure space for date range */
            text-align: center;
        }

        .gantt-container {
            /* width: 95%; Remove fixed width */
            /* max-width: 1200px; Remove max-width */
            width: 100%; /* Take full width */
            overflow-x: auto; /* Allow horizontal scroll for grid */
            overflow-y: auto; /* Allow vertical scroll for grid */
            border: 1px solid #333;
            border-radius: 8px;
            background-color: #2a2a2a;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            flex-grow: 1; /* Allow container to fill remaining vertical space */
            position: relative; /* Needed for sticky headers to work within */
        }

        .gantt-grid {
            display: grid;
            grid-template-columns: 150px repeat(12, 1fr); /* Team members column + 12 months */
            position: relative;
        }

        .gantt-header, .gantt-row {
            display: contents; /* Allows children to be direct grid items */
        }

        .gantt-cell {
            padding: 0; 
            border-bottom: 1px solid #333;
            border-right: 1px solid #333;
            text-align: center;
            font-size: 0.9em;
            white-space: nowrap;
            position: relative; 
            overflow: visible; 
            box-sizing: border-box; /* Explicitly set box-sizing */
            /* min-height: 30px; Remove fixed min height, let it be set by row height */
        }

        .gantt-header .gantt-cell {
            background-color: #333333;
            color: #bb86fc;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 2;
            padding: 8px 10px; /* Adjusted padding */
            min-height: auto; /* Reset min-height for header */
        }
         .gantt-header .gantt-cell:first-child {
            position: sticky;
            left: 0;
            z-index: 3;
        }

        .gantt-member-name {
            background-color: #3a3a3a;
            font-weight: bold;
            text-align: left;
            position: sticky;
            left: 0;
            z-index: 1;
             display: flex; 
             align-items: center;
             justify-content: space-between;
             padding-left: 8px; /* Adjusted padding */
             padding-right: 8px; /* Adjusted padding */
             overflow: hidden;
             white-space: nowrap;
             text-overflow: ellipsis;
             box-sizing: border-box; /* Explicitly set box-sizing */
        }
         .gantt-member-name > span:first-child { /* Target the name span specifically */
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            flex-grow: 1; /* Allow name to take available space */
            min-width: 0; /* Prevent flex item from overflowing */
        }

        .gantt-task-bar-container {
           /* This class might not be strictly needed anymore, cells act as containers */
           /* We'll position task bars directly relative to .gantt-cell */
            height: 100%;
            width: 100%;
        }

        .gantt-task-bar {
            position: absolute;
            /* height will be set by JS based on laneHeight */
            background-color: #03dac6; /* Default/fallback color */
            border-radius: 4px;
            /* margin: auto 2px; remove margin, use top/left positioning */
            opacity: 0.8;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis; /* Add ... for overflow */
            text-align: left;
            padding-left: 5px;
            box-sizing: border-box;
            color: #121212;
            font-size: 0.8em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: background-color 0.3s ease, opacity 0.3s ease;
            z-index: 1; /* Ensure tasks are above grid lines but below headers */
        }
        .gantt-task-bar:hover {
            opacity: 1;
            background-color: #018786;
        }

        /* Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.7); /* Black w/ opacity */
            padding-top: 60px;
        }

        .modal-content {
            background-color: #2a2a2a; /* Dark background for modal */
            color: #e0e0e0;
            margin: 5% auto;
            padding: 15px 20px; /* Adjusted padding */
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            position: relative;
        }

        .close-button {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
        }

        .close-button:hover,
        .close-button:focus {
            color: #bb86fc; /* Highlight color on hover */
            text-decoration: none;
            cursor: pointer;
        }

        /* Style for past month cells */
        .gantt-past-month {
            background-color: #222; /* Slightly darker than default cell bg */
            /* opacity: 0.7; */ /* Alternative: make it slightly transparent */
        }

        .gantt-header .gantt-past-month {
            background-color: #282828; /* Slightly darker than default header bg */
        }

        .member-status-indicators {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-shrink: 0;
        }

        .member-overdue-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: #ef5350;
            border-radius: 50%;
            margin-left: 8px;
        }

        .member-overdue-count {
            font-size: 0.8em;
            color: #ef5350;
            font-weight: bold;
            background-color: rgba(239, 83, 80, 0.1);
            padding: 1px 4px;
            border-radius: 3px;
        }

        /* Task Status Styles */
        .gantt-task-bar.task-completed {
            opacity: 0.6;
            border: 1px dashed #888;
        }
         .gantt-task-bar.task-completed::before {
            content: 'âœ“';
            margin-right: 4px;
            color: #333;
            font-weight: bold;
        }

        .gantt-task-bar.task-overdue {
            border: 2px solid #ef5350;
            box-shadow: 0 0 5px rgba(239, 83, 80, 0.5);
        }

        .gantt-task-bar.task-overdue::after {
            content: '!';
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            color: #fff;
            background-color: #ef5350;
            border-radius: 50%;
            width: 14px;
            height: 14px;
            text-align: center;
            line-height: 14px;
            font-size: 10px;
            font-weight: bold;
        }

        /* Member Modal Specific Styles */
        #memberModal .modal-content {
             max-width: 600px; /* Allow slightly wider modal */
        }

        #memberTaskList {
            list-style: none;
            padding: 0;
            margin-top: 10px;
            max-height: 200px; /* Limit height and allow scroll */
            overflow-y: auto;
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #333; /* Slightly different bg for list */
        }
         #memberTaskList li {
            padding: 4px 8px; /* Reduced padding */
            border-bottom: 1px solid #444;
        }

        #memberTaskList li:last-child {
            border-bottom: none;
        }

        #memberTaskList .task-detail-status {
            font-size: 0.8em;
            margin-left: 10px;
            padding: 1px 4px;
            border-radius: 3px;
            opacity: 0.8;
        }
        #memberTaskList .task-detail-status.completed {
            background-color: #555;
            color: #ccc;
        }
        #memberTaskList .task-detail-status.overdue {
             background-color: rgba(239, 83, 80, 0.2);
             color: #ef9a9a;
        }
         #memberTaskList .task-detail-status.in-progress {
             background-color: rgba(3, 218, 198, 0.1);
             color: #80cbc4;
        }

        /* Deadline Styles */
        .gantt-deadline-month {
            background-color: rgba(187, 134, 252, 0.08); /* Faint highlight using theme color */
        }

        .gantt-header .gantt-deadline-month {
            background-color: rgba(187, 134, 252, 0.15); /* Slightly stronger for header */
        }

        .deadline-marker {
            font-size: 0.8em;
            cursor: pointer; /* Indicate clickable for later */
            /* display: inline-block; */ /* Needed if not using flex on parent */
            /* vertical-align: middle; */
             filter: grayscale(30%); /* Slightly desaturate emoji */
             transition: filter 0.2s ease;
        }
        .deadline-marker:hover {
            filter: grayscale(0%);
        }

        .gantt-header .gantt-cell > div {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px; /* Space between text and marker */
            height: 100%;
        }

        /* Month Summary Modal List Styles */
        #monthSummaryDeadlineList, #monthSummaryTaskList {
            list-style: none;
            padding: 0;
            margin-top: 5px;
            margin-bottom: 15px;
            max-height: 150px; /* Limit height */
            overflow-y: auto;
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #333;
        }
         #monthSummaryDeadlineList li, #monthSummaryTaskList li {
            padding: 4px 8px; 
            border-bottom: 1px solid #444;
        }
         #monthSummaryDeadlineList li:last-child, #monthSummaryTaskList li:last-child {
            border-bottom: none;
        }
        /* Reuse task status styles */
        #monthSummaryTaskList .task-detail-status {
             font-size: 0.8em;
             margin-left: 10px;
             padding: 1px 4px;
             border-radius: 3px;
             opacity: 0.8;
         }
         #monthSummaryTaskList .task-detail-status.completed {
             background-color: #555;
             color: #ccc;
         }
         #monthSummaryTaskList .task-detail-status.overdue {
              background-color: rgba(239, 83, 80, 0.2);
              color: #ef9a9a;
         }
          #monthSummaryTaskList .task-detail-status.in-progress {
              background-color: rgba(3, 218, 198, 0.1);
              color: #80cbc4;
         }

        /* View Switcher Styles */
        .view-switcher {
            margin-left: auto; /* Push to the right */
            display: flex;
            gap: 5px;
        }

        .view-toggle-btn {
            background-color: #3a3a3a;
            color: #aaa; /* Default inactive color */
            border: 1px solid #555;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        .view-toggle-btn:hover {
            background-color: #4a4a4a;
            color: #e0e0e0;
        }

        .view-toggle-btn.active {
            background-color: #bb86fc;
            color: #1e1e1e;
            font-weight: bold;
            border-color: #bb86fc;
        }

        /* Board View Styles */
        .board-container {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Space between sections */
        }

        .board-section {
            background-color: #333;
            padding: 15px;
            border-radius: 6px;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
        }

        .board-section h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #bb86fc;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }
         .board-section h3 .current-month-label {
            font-size: 0.9em;
            color: #aaa;
            font-weight: normal;
            margin-left: 10px;
        }

        /* Style for overdue section title */
        .board-section.overdue-section h3 {
            color: #ef5350; /* Red color for overdue */
            border-bottom-color: #ef5350;
        }

        .board-task-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid; /* Changed from flex to grid */
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); /* Responsive grid columns */
            gap: 12px; /* Increased gap for grid layout */
        }

        .board-task-card {
            background-color: #444;
            padding: 10px 12px;
            border-radius: 4px;
            border-left: 4px solid #03dac6; /* Default accent */
            font-size: 0.9em;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
            transition: background-color 0.2s ease;
            color: #e0e0e0;
        }
        .board-task-card:hover {
            background-color: #4f4f4f;
        }

        .board-task-card strong {
            display: block; /* Task name on its own line */
            margin-bottom: 4px;
            color: #e0e0e0;
        }

        .board-task-card .assignees, .board-task-card .date-info {
            font-size: 0.85em;
            color: #bbb;
            margin-top: 2px;
        }

        .board-task-card .description {
            font-size: 0.8em;
            color: #ccc;
            margin-top: 6px;
            font-style: italic;
            /* Limit description lines and add ellipsis if needed */
            display: -webkit-box;
            -webkit-line-clamp: 2; /* Show max 2 lines */
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
            max-height: calc(1.3em * 2); /* line-height * number of lines */
        }

        .pagination-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #555;
        }

        .pagination-controls button {
             background-color: #3a3a3a;
             color: #e0e0e0;
             border: 1px solid #555;
             padding: 4px 8px;
             border-radius: 4px;
             cursor: pointer;
             transition: background-color 0.2s ease;
             font-size: 0.9em;
        }
         .pagination-controls button:hover:not(:disabled) {
             background-color: #4a4a4a;
         }
         .pagination-controls button:disabled {
             background-color: #2a2a2a;
             color: #666;
             cursor: not-allowed;
             border-color: #444;
         }
         .pagination-controls span {
            font-size: 0.9em;
            color: #aaa;
         }

    </style>
</head>
<body>
    <div class="main-content">
        <h1>Drakeling Labs Studios</h1>
        <h2 class="subtitle">Task Management Board</h2>

        <div class="tab-container">
            <button class="tab-scroll-btn left" id="tabScrollLeftBtn" disabled>&lt;</button>
            <div class="tab-list-wrapper">
                <div class="tab-list" id="tabList">
                    <!-- Tabs will be generated here -->
                </div>
            </div>
            <button class="tab-scroll-btn right" id="tabScrollRightBtn" disabled>&gt;</button>
        </div>

        <div class="gantt-controls">
            <button id="zoomInBtn" title="Zoom In (+)">-</button>
            <button id="zoomOutBtn" title="Zoom Out (-)">+</button> 
            <button id="prevMonthBtn" title="Previous Month">&lt;</button>
            <span id="dateRangeSpan"></span> <!-- To show current visible range -->
            <button id="nextMonthBtn" title="Next Month">&gt;</button>

            <!-- View Switcher -->
            <div class="view-switcher">
                <button id="ganttViewBtn" class="view-toggle-btn active" data-view="gantt">Gantt</button>
                <button id="boardViewBtn" class="view-toggle-btn" data-view="board">Board</button>
            </div>
        </div>
        <div class="gantt-container">
            <div class="gantt-grid" id="ganttGrid">
                <!-- Grid will be generated by JavaScript -->
            </div>
        </div>
        <!-- Container for Board View (Initially Hidden) -->
        <div class="board-container" id="boardContainer" style="display: none; flex-grow: 1; overflow: auto; padding: 10px; background-color: #2a2a2a; border: 1px solid #333; border-radius: 8px; margin-top: 10px;">
             <!-- Board content will go here -->
        </div>
    </div>

    <!-- Modals remain outside main-content for full overlay -->
    <!-- The Modal -->
    <div id="taskModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeModalButton">&times;</span>
            <h2>Task Details</h2>
            <p><strong>Task:</strong> <span id="modalTaskName"></span></p>
            <p id="modalTaskDescriptionContainer" style="display: none;"> <!-- Add container, hidden by default -->
                <strong>Description:</strong> <span id="modalTaskDescription" style="font-style: italic;"></span>
            </p>
            <p><strong>Project:</strong> <span id="modalProjectName"></span></p>
            <p><strong>Assignee:</strong> <span id="modalAssignee"></span></p>
            <p><strong>Duration:</strong> <span id="modalDuration"></span></p>
            <p><strong>Status:</strong> <span id="modalStatus">Not implemented</span></p>
        </div>
    </div>

    <!-- The Member Modal -->
    <div id="memberModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeMemberModalButton">&times;</span>
            <h2>Team Member Details</h2>
            <p><strong>Name:</strong> <span id="modalMemberName"></span></p>
            <p><strong>Role:</strong> <span id="modalMemberRole"></span></p>
            <p><strong>Overdue Tasks:</strong> <span id="modalMemberOverdue"></span></p>
            <p><strong>Upcoming Tasks:</strong> <span id="modalMemberUpcoming"></span></p>
            <p><strong>Assigned Tasks (Current Project):</strong></p>
            <ul id="memberTaskList">
                <!-- Task list will be populated here -->
            </ul>
        </div>
    </div>

    <!-- The Month Summary Modal -->
    <div id="monthSummaryModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeMonthSummaryModalButton">&times;</span>
            <h2>Summary for <span id="modalMonthSummaryMonthYear"></span></h2>
            
            <h4>Deadlines:</h4>
            <ul id="monthSummaryDeadlineList">
                <!-- Deadline list -->
            </ul>

            <h4>Tasks (Active this Month):</h4>
            <ul id="monthSummaryTaskList">
                 <!-- Task list -->
            </ul>
        </div>
    </div>

    <script src="data.js"></script> <!-- Load data first -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // --- DOM Elements ---
            const ganttGrid = document.getElementById('ganttGrid');
            const taskModal = document.getElementById('taskModal');
            const closeModalButton = document.getElementById('closeModalButton');
            const modalTaskName = document.getElementById('modalTaskName');
            const modalAssignee = document.getElementById('modalAssignee');
            const modalDuration = document.getElementById('modalDuration');
            const modalStatus = document.getElementById('modalStatus');
            const modalProjectName = document.getElementById('modalProjectName'); // Get the new element
            const modalTaskDescriptionContainer = document.getElementById('modalTaskDescriptionContainer'); // Get the container
            const modalTaskDescription = document.getElementById('modalTaskDescription'); // Get the description span
            const prevMonthBtn = document.getElementById('prevMonthBtn');
            const nextMonthBtn = document.getElementById('nextMonthBtn');
            const dateRangeSpan = document.getElementById('dateRangeSpan');
            const tabList = document.getElementById('tabList');
            const tabScrollLeftBtn = document.getElementById('tabScrollLeftBtn');
            const tabScrollRightBtn = document.getElementById('tabScrollRightBtn');
            const tabListWrapper = document.querySelector('.tab-list-wrapper'); // Get wrapper for width check
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const zoomInBtn = document.getElementById('zoomInBtn');
            // Member Modal Elements
            const memberModal = document.getElementById('memberModal');
            const closeMemberModalButton = document.getElementById('closeMemberModalButton');
            const modalMemberName = document.getElementById('modalMemberName');
            const modalMemberRole = document.getElementById('modalMemberRole');
            const modalMemberOverdue = document.getElementById('modalMemberOverdue');
            const modalMemberUpcoming = document.getElementById('modalMemberUpcoming');
            const memberTaskList = document.getElementById('memberTaskList');
            // Month Summary Modal Elements
            const monthSummaryModal = document.getElementById('monthSummaryModal');
            const closeMonthSummaryModalButton = document.getElementById('closeMonthSummaryModalButton');
            const modalMonthSummaryMonthYear = document.getElementById('modalMonthSummaryMonthYear');
            const monthSummaryDeadlineList = document.getElementById('monthSummaryDeadlineList');
            const modalMonthSummaryTaskList = document.getElementById('monthSummaryTaskList');
            // View Containers and Buttons
            const ganttContainer = document.querySelector('.gantt-container'); // Reference existing container
            const boardContainer = document.getElementById('boardContainer');
            const ganttViewBtn = document.getElementById('ganttViewBtn');
            const boardViewBtn = document.getElementById('boardViewBtn');

            // --- Gantt State / Constants ---
            const laneHeight = 35; 
            const taskVerticalPadding = 5; 
            const taskBarHeight = laneHeight - (2 * taskVerticalPadding);
            const startYear = 2024;
            const maxVisibleMonths = 12;
            const minVisibleMonths = 3; 
            let visibleMonthsCount = maxVisibleMonths; // Default to max zoom out
            let currentStartMonthIndex = 0;
            let currentProjectId = "all"; // Default to "All Projects" view
            let currentView = 'gantt'; // Add current view state
            let upcomingTasksCurrentPage = 1; // State for board pagination
            const tasksPerPage = 5; // Configurable items per page for board
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            // Procedural Color Palette for tasks
            const taskColorPalette = [
                '#ef5350', '#EC407A', '#AB47BC', '#7E57C2', '#5C6BC0', // Reds/Pinks/Purples
                '#42A5F5', '#29B6F6', '#26C6DA', '#26A69A', '#66BB6A', // Blues/Teals/Greens
                '#9CCC65', '#D4E157', '#FFEE58', '#FFCA28', '#FFA726', // Limes/Yellows/Oranges
                '#FF7043', '#8D6E63', '#BDBDBD', '#78909C' // Orange/Brown/Grey/Blue Grey
            ]; 
            
            // Data is now loaded from data.js (implicitly global)
            // const teamMembers = [ ... ]; 
            // const projects = [ ... ];
            // const globalDeadlines = [ ... ];

             // --- Helper function to determine text color based on background luminance ---
            function getTextColorForBackground(hexColor) {
                // Convert hex to RGB
                const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                hexColor = hexColor.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexColor);
                if (!result) return '#e0e0e0'; // Default light text on error
    
                const r = parseInt(result[1], 16);
                const g = parseInt(result[2], 16);
                const b = parseInt(result[3], 16);
    
                // Calculate luminance (using standard formula)
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    
                // Return dark text for light backgrounds, light text for dark backgrounds
                return luminance > 0.5 ? '#1e1e1e' : '#e0e0e0';
            }

            function getCurrentProject() {
                if (currentProjectId === "all") {
                    const allTasks = projects.reduce((acc, p) => acc.concat(p.tasks), []);
                    // Ensure unique IDs for tasks if they are not already globally unique
                    // For now, we assume task IDs are unique within their original project context and this is sufficient for display
                    // If operations require globally unique IDs, this would need adjustment.
                    const allDeadlines = projects.reduce((acc, p) => acc.concat(p.deadlines || []), []);
                    return {
                        id: "all",
                        name: "All Projects",
                        tasks: allTasks,
                        deadlines: allDeadlines
                    };
                }
                return projects.find(p => p.id === currentProjectId);
            }

            // --- Helper Functions for Date Handling ---
            function dateToMonthIndex(date) {
                return (date.year - startYear) * 12 + (date.month - 1);
            }

            function monthIndexToDate(monthIndex) {
                const year = startYear + Math.floor(monthIndex / 12);
                const month = (monthIndex % 12) + 1;
                return { year, month };
            }

            function getFormattedMonthYear(monthIndex) {
                const date = monthIndexToDate(monthIndex);
                const monthName = monthNames[date.month - 1];
                return `${monthName} ${date.year}`;
            }

            // --- Initialize View ---
            function initializeView() {
                renderTabs(); 
                const project = getCurrentProject();
                if (!project) {
                    ganttGrid.innerHTML = '<p style="padding: 20px; text-align: center;">Select a project.</p>';
                    return; 
                }
                // No longer need project tasks to determine initial view
                // const tasks = project.tasks;
                // const latestTaskEndMonth = tasks.reduce((max, task) => Math.max(max, task.endMonth), -1);
                
                // Calculate initial view based on current date
                const now = new Date();
                const currentRealYear = now.getFullYear();
                const currentRealMonthIndex = now.getMonth(); // 0-indexed
                const currentAbsoluteMonthIndex = (currentRealYear - startYear) * 12 + currentRealMonthIndex;
                
                // Set start index to 2 months before current month
                currentStartMonthIndex = currentAbsoluteMonthIndex - 2; 
                
                // Boundary checks
                currentStartMonthIndex = Math.max(0, currentStartMonthIndex); // Ensure not less than 0
                
                // Ensure valid index if total months < visible months (edge case)
                if(currentStartMonthIndex < 0) currentStartMonthIndex = 0; 

                // renderGantt(); No longer call directly, use renderCurrentView
                renderCurrentView(); // Call the new view rendering function
                updateTabScrollButtons(); 
            }

            // --- Modal Functions --- 
            function openModal(task, projectName) { // Add projectName parameter
                // const project = getCurrentProject(); // No longer need this here as project name is passed
                // if (!project) return; // No longer need this check here
                
                const assignees = teamMembers.filter(m => task.memberIds.includes(m.id));
                const assigneeNames = assignees.map(m => m.name).join(', ') || 'Unknown';
                
                const startMonthStr = getFormattedMonthYear(dateToMonthIndex(task.startDate));
                const endMonthStr = getFormattedMonthYear(dateToMonthIndex(task.endDate));

                // Determine Status for Modal
                const now = new Date();
                const currentRealYear = now.getFullYear();
                const currentRealMonthIndex = now.getMonth();
                let statusText = "In Progress";
                const currentAbsoluteMonthIndex = (currentRealYear - startYear) * 12 + currentRealMonthIndex;
                const isOverdueModal = !task.completed && (dateToMonthIndex(task.endDate) < currentAbsoluteMonthIndex);

                if (task.completed) {
                    statusText = "Completed";
                } else if (isOverdueModal) {
                    statusText = "Overdue";
                }

                modalTaskName.textContent = task.name;
                modalAssignee.textContent = assigneeNames;
                modalDuration.textContent = `${startMonthStr} - ${endMonthStr}`;
                modalStatus.textContent = statusText;
                modalProjectName.textContent = projectName || 'N/A'; // Display the project name

                if (task.description) {
                    modalTaskDescription.innerHTML = task.description;
                    modalTaskDescriptionContainer.style.display = 'block';
                } else {
                    modalTaskDescriptionContainer.style.display = 'none';
                }

                taskModal.style.display = 'block';
            }

            function closeModal() {
                taskModal.style.display = 'none';
            }

            // Close modal events
            closeModalButton.onclick = closeModal;
            window.onclick = function(event) { // Close if clicked outside modal content
                if (event.target == taskModal) {
                    closeModal();
                }
            }
            window.onkeydown = function(event) { // Close with Escape key
                if (event.key === "Escape") {
                    closeModal();
                }
            }

            // --- Tab Functions ---
            function renderTabs() {
                tabList.innerHTML = ''; // Clear existing tabs

                // Add "All Projects" tab first
                const allProjectsTab = document.createElement('div');
                allProjectsTab.classList.add('tab');
                allProjectsTab.textContent = "All Projects";
                allProjectsTab.dataset.projectId = "all";
                if (currentProjectId === "all") {
                    allProjectsTab.classList.add('active');
                }
                allProjectsTab.addEventListener('click', handleTabClick);
                tabList.appendChild(allProjectsTab);

                projects.forEach(project => {
                    const tab = document.createElement('div');
                    tab.classList.add('tab');
                    tab.textContent = project.name;
                    tab.dataset.projectId = project.id;
                    if (project.id === currentProjectId) {
                        tab.classList.add('active');
                    }
                    tab.addEventListener('click', handleTabClick);
                    tabList.appendChild(tab);
                });
                updateTabScrollButtons(); // Update scroll buttons after rendering
            }

            function handleTabClick(event) {
                const newProjectIdStr = event.target.dataset.projectId;
                const newProjectId = (newProjectIdStr === "all") ? "all" : parseInt(newProjectIdStr);
                
                if (newProjectId !== currentProjectId) {
                    currentProjectId = newProjectId;
                    renderTabs(); // Re-render tabs to update active state
                    initializeView(); // Re-initialize and render Gantt for the new project
                }
            }

            function updateTabScrollButtons() {
                 // Use setTimeout to allow the browser to render tabs and calculate widths accurately
                setTimeout(() => {
                    const wrapperWidth = tabListWrapper.offsetWidth;
                    const listWidth = tabList.scrollWidth;
                    const currentScroll = tabListWrapper.scrollLeft;
                    
                    tabScrollLeftBtn.disabled = currentScroll <= 0;
                    tabScrollRightBtn.disabled = currentScroll >= listWidth - wrapperWidth -1; // -1 for potential rounding issues

                    // Hide buttons altogether if no overflow
                    if (listWidth <= wrapperWidth) {
                        tabScrollLeftBtn.style.display = 'none';
                        tabScrollRightBtn.style.display = 'none';
                    } else {
                        tabScrollLeftBtn.style.display = 'block';
                        tabScrollRightBtn.style.display = 'block';
                    }
                }, 50); // Small delay
            }

            function scrollTabs(direction) {
                const scrollAmount = tabListWrapper.offsetWidth * 0.8; // Scroll 80% of the visible width
                tabListWrapper.scrollBy({ 
                    left: direction * scrollAmount, 
                    behavior: 'smooth' 
                });
                // Update buttons after scroll animation might finish
                setTimeout(updateTabScrollButtons, 350); // Corresponds to smooth scroll duration
            }

            // Attach scroll button listeners
            tabScrollLeftBtn.addEventListener('click', () => scrollTabs(-1));
            tabScrollRightBtn.addEventListener('click', () => scrollTabs(1));
            // Update scroll buttons on window resize
            window.addEventListener('resize', updateTabScrollButtons);
            // Also update on scroll (e.g., manual scroll via touchpad)
            tabListWrapper.addEventListener('scroll', updateTabScrollButtons);

            // --- Main Rendering Function --- 
            // This will now decide WHICH view to render
            function renderCurrentView() {
                console.log("Rendering view:", currentView);
                if (currentView === 'gantt') {
                    boardContainer.style.display = 'none';
                    ganttContainer.style.display = 'block'; // Ensure Gantt is visible
                    renderGantt();
                } else if (currentView === 'board') {
                    ganttContainer.style.display = 'none';
                    boardContainer.style.display = 'block';
                    renderBoard(); // Call the new board rendering function
                }
            }

            function renderGantt() {
                const project = getCurrentProject();
                if (!project) {
                    ganttGrid.innerHTML = '<p style="padding: 20px; text-align: center;">Select a project.</p>';
                    return; 
                }
                const tasks = project.tasks;
                
                // Filter team members for the current project
                let projectMembers;
                if (currentProjectId === "all") {
                    projectMembers = [...teamMembers]; // Show all members for "All Projects" view
                } else {
                    projectMembers = teamMembers.filter(member => 
                        member.projectIds && member.projectIds.includes(currentProjectId)
                    );
                }
                
                // Get current real-world date (once per render)
                const now = new Date();
                const currentRealYear = now.getFullYear();
                const currentRealMonthIndex = now.getMonth(); // 0-indexed (Jan=0)
                // Calculate current month index relative to startYear
                const currentAbsoluteMonthIndex = (currentRealYear - startYear) * 12 + currentRealMonthIndex;

                // Calculate overdue tasks per member FOR THIS PROJECT
                projectMembers.forEach(member => {
                    member.overdueTaskCount = project.tasks.filter(task => 
                        task.memberIds.includes(member.id) && // Check if member is in the array
                        !task.completed &&
                        (dateToMonthIndex(task.endDate) < currentAbsoluteMonthIndex)
                    ).length;
                });

                ganttGrid.innerHTML = ''; // Clear previous grid

                // Determine visible months & years
                const actualVisibleMonthsCount = visibleMonthsCount;
                const visibleMonthDetails = [];
                for (let i = 0; i < actualVisibleMonthsCount; i++) {
                    const monthIndex = currentStartMonthIndex + i;
                    const year = startYear + Math.floor(monthIndex / 12);
                    const monthName = monthNames[monthIndex % 12];
                    visibleMonthDetails.push({ name: monthName, year: year, shortYear: String(year).slice(-2), fullIndex: monthIndex });
                }

                // Update date range display
                if (visibleMonthDetails.length > 0) {
                    const firstVisible = visibleMonthDetails[0];
                    const lastVisible = visibleMonthDetails[visibleMonthDetails.length - 1];
                    dateRangeSpan.textContent = `${firstVisible.name} ${firstVisible.year} - ${lastVisible.name} ${lastVisible.year}`;
                }

                // Update button states (Navigation and Zoom)
                prevMonthBtn.disabled = currentStartMonthIndex === 0;
                nextMonthBtn.disabled = false;
                zoomOutBtn.disabled = visibleMonthsCount <= minVisibleMonths;
                zoomInBtn.disabled = visibleMonthsCount >= maxVisibleMonths;

                // Adjust grid columns
                ganttGrid.style.gridTemplateColumns = `150px repeat(${actualVisibleMonthsCount}, 1fr)`;

                // --- Lane Calculation for currently visible tasks ---
                let tasksToRender = [];
                tasks.forEach(task => {
                    const startMonthIndex = dateToMonthIndex(task.startDate);
                    const endMonthIndex = dateToMonthIndex(task.endDate);
                    // Check if task is visible in the current window
                    if (endMonthIndex >= currentStartMonthIndex && startMonthIndex < currentStartMonthIndex + actualVisibleMonthsCount) {
                        tasksToRender.push({
                            ...task,
                            startMonth: startMonthIndex,
                            endMonth: endMonthIndex,
                            lane: -1
                        });
                    }
                });
                
                // Calculate lanes based on filtered project members
                projectMembers.forEach((member, memberIndex) => {
                    const memberTasks = tasksToRender
                        .filter(t => t.memberIds.includes(member.id)) // Filter tasks where member is assigned
                        .sort((a, b) => a.startMonth - b.startMonth || a.endMonth - b.endMonth);
                    
                    let lanes = []; 
                    let maxLanes = 0;
                    memberTasks.forEach(task => {
                        let assignedLane = -1;
                        for (let i = 0; i < lanes.length; i++) {
                            if (task.startMonth > lanes[i]) { 
                                lanes[i] = task.endMonth;
                                assignedLane = i;
                                break;
                            }
                        }
                        if (assignedLane === -1) { 
                            lanes.push(task.endMonth);
                            assignedLane = lanes.length - 1;
                        }
                        // task_for_max_lane_calc.lane = assignedLane; // DO NOT WRITE TO THE SHARED TASK OBJECT HERE
                        maxLanes = Math.max(maxLanes, lanes.length);
                    });
                    member.currentMaxLanes = maxLanes || 1; 
                });

                // --- Render Header ---
                const header = document.createElement('div');
                header.classList.add('gantt-header');
                const emptyCell = document.createElement('div');
                emptyCell.classList.add('gantt-cell');
                header.appendChild(emptyCell);
                visibleMonthDetails.forEach(monthDetail => {
                    const cell = document.createElement('div');
                    cell.classList.add('gantt-cell');
                    
                    // Content wrapper for flex layout
                    const cellContent = document.createElement('div'); 
                    const monthText = document.createElement('span');
                    monthText.textContent = `${monthDetail.name} '${monthDetail.shortYear}`;
                    cellContent.appendChild(monthText);

                    // Check for deadlines in this month for the CURRENT project
                    const projectDeadlines = project.deadlines || [];
                    const deadlinesForMonth = projectDeadlines.filter(d => 
                        dateToMonthIndex(d.date) === monthDetail.fullIndex
                    );
                    
                    if (deadlinesForMonth.length > 0) {
                        cell.classList.add('gantt-deadline-month');
                        
                        // Add first deadline marker (can enhance later for multiple)
                        const marker = document.createElement('span');
                        marker.classList.add('deadline-marker');
                        marker.textContent = 'ðŸš©'; // Example marker
                        marker.title = deadlinesForMonth[0].name; // Show first deadline name on hover
                        cellContent.appendChild(marker);
                    }

                    // Check if this header cell represents a past month
                    if (monthDetail.year < currentRealYear || (monthDetail.year === currentRealYear && monthDetail.fullIndex % 12 < currentRealMonthIndex)) {
                        cell.classList.add('gantt-past-month');
                    }
                    
                    // Make the whole content cell clickable for month summary
                    cellContent.style.cursor = 'pointer';
                    cellContent.dataset.monthIndex = monthDetail.fullIndex;
                    cellContent.onclick = (e) => {
                         // Get month index from the dataset attribute
                        const clickedMonthIndex = parseInt(e.currentTarget.dataset.monthIndex);
                        openMonthSummaryModal(clickedMonthIndex);
                    };

                    cell.appendChild(cellContent); // Add content wrapper to cell
                    header.appendChild(cell);
                });
                ganttGrid.appendChild(header);

                // --- Render Rows for each Team Member ---
                projectMembers.forEach((member, memberIndex) => {
                    const row = document.createElement('div');
                    row.classList.add('gantt-row');
                    const memberRowHeight = (member.currentMaxLanes || 1) * laneHeight;

                    const nameCell = document.createElement('div');
                    nameCell.classList.add('gantt-cell', 'gantt-member-name');
                    nameCell.style.height = `${memberRowHeight}px`;
                    
                    // Add name and status indicators
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = member.name;
                    nameSpan.title = member.name; // Keep tooltip for full name
                    nameSpan.style.cursor = 'pointer'; // Make name clickable
                    nameSpan.addEventListener('click', () => openMemberModal(member.id));
                    nameCell.appendChild(nameSpan);

                    if (member.overdueTaskCount > 0) {
                        const indicatorsSpan = document.createElement('span');
                        indicatorsSpan.classList.add('member-status-indicators');
                        
                        const overdueIndicator = document.createElement('span');
                        overdueIndicator.classList.add('member-overdue-indicator');
                        overdueIndicator.title = `${member.overdueTaskCount} overdue task(s)`;
                        indicatorsSpan.appendChild(overdueIndicator);

                        const overdueCount = document.createElement('span');
                        overdueCount.classList.add('member-overdue-count');
                        overdueCount.textContent = member.overdueTaskCount;
                        indicatorsSpan.appendChild(overdueCount);

                        nameCell.appendChild(indicatorsSpan);
                    }
                    
                    row.appendChild(nameCell);

                    const monthCellsElements = [];
                    visibleMonthDetails.forEach((monthDetail, indexInView) => {
                        const monthCell = document.createElement('div');
                        monthCell.classList.add('gantt-cell');
                        monthCell.style.height = `${memberRowHeight}px`;
                        
                        // Apply deadline column class
                        const currentProjectDeadlines = project.deadlines || [];
                        if (currentProjectDeadlines.some(d => dateToMonthIndex(d.date) === monthDetail.fullIndex)) {
                             monthCell.classList.add('gantt-deadline-month');
                        }
                        
                        // Check if this grid cell represents a past month
                        if (monthDetail.year < currentRealYear || (monthDetail.year === currentRealYear && monthDetail.fullIndex % 12 < currentRealMonthIndex)) {
                            monthCell.classList.add('gantt-past-month');
                        }
                        row.appendChild(monthCell);
                        monthCellsElements.push(monthCell);
                    });

                    // Determine width of one month cell for this row (same for all)
                    const oneMonthCellWidth = monthCellsElements[0] ? monthCellsElements[0].offsetWidth : 0;

                    // Get this member's tasks, sorted correctly for local lane assignment during rendering
                    const memberTasksSortedForRendering = tasksToRender
                        .filter(t => t.memberIds.includes(member.id))
                        .sort((a, b) => a.startMonth - b.startMonth || a.endMonth - b.endMonth);
                    
                    let occupiedLanesEndMonths = []; // Tracks end months for tasks in *this specific member's row*

                    memberTasksSortedForRendering.forEach(task => {
                        // Calculate the correct lane for this task within this member's row
                        let actualRenderLane = -1;
                        for (let i = 0; i < occupiedLanesEndMonths.length; i++) {
                            if (task.startMonth > occupiedLanesEndMonths[i]) { 
                                occupiedLanesEndMonths[i] = task.endMonth;
                                actualRenderLane = i;
                                break;
                            }
                        }
                        if (actualRenderLane === -1) { 
                            occupiedLanesEndMonths.push(task.endMonth);
                            actualRenderLane = occupiedLanesEndMonths.length - 1;
                        }

                        const taskBar = document.createElement('div');
                        taskBar.classList.add('gantt-task-bar');
                        taskBar.textContent = task.name;
                        taskBar.title = task.name;

                        const colorIndex = (memberIndex + actualRenderLane) % taskColorPalette.length; // Use actualRenderLane for color variation too
                        const bgColor = taskColorPalette[colorIndex];
                        taskBar.style.backgroundColor = bgColor;
                        taskBar.style.color = getTextColorForBackground(bgColor);
                        
                        // Apply status classes (isOverdue was defined earlier in renderGantt)
                        // We need to recalculate isOverdue based on currentAbsoluteMonthIndex or pass it if needed
                        // For simplicity, let's grab currentAbsoluteMonthIndex again or ensure it's accessible
                        // It's defined in the outer scope of renderGantt, so it is accessible here.
                        const isTaskOverdue = !task.completed && (dateToMonthIndex(task.endDate) < currentAbsoluteMonthIndex);
                        if (task.completed) {
                            taskBar.classList.add('task-completed');
                        } else if (isTaskOverdue) {
                            taskBar.classList.add('task-overdue');
                        }
                        
                        const visibleTaskStartMonth = Math.max(task.startMonth, currentStartMonthIndex);
                        const visibleTaskEndMonth = Math.min(task.endMonth, currentStartMonthIndex + actualVisibleMonthsCount - 1);
                        
                        const startOffsetInWindow = visibleTaskStartMonth - currentStartMonthIndex;
                        const durationInWindow = visibleTaskEndMonth - visibleTaskStartMonth + 1;

                        if (durationInWindow <= 0) return; 

                        // Calculate width in pixels to avoid sub-pixel rounding issues with percentage widths
                        if (oneMonthCellWidth > 0) {
                            const widthPx = durationInWindow * oneMonthCellWidth - 4; // subtract 4px for padding
                            taskBar.style.width = `${widthPx}px`;
                        } else {
                            // fallback to percentage width if measurement failed
                            taskBar.style.width = `calc(${durationInWindow * 100}% - 4px)`;
                        }
                        taskBar.style.left = '2px'; 
                        taskBar.style.top = `${actualRenderLane * laneHeight + taskVerticalPadding}px`; // USE actualRenderLane HERE
                        taskBar.style.height = `${taskBarHeight}px`;
                        taskBar.style.cursor = 'pointer';
                        taskBar.dataset.taskId = task.id;
                        taskBar.addEventListener('click', (event) => {
                            event.stopPropagation();
                            const clickedTask = tasks.find(t => t.id === parseInt(event.currentTarget.dataset.taskId));
                            // Find the original project for this task
                            let originalProjectName = "Unknown Project";
                            if (currentProjectId === "all") {
                                const sourceProject = projects.find(p => p.tasks.some(t_orig => t_orig.id === clickedTask.id && t_orig.name === clickedTask.name)); // Heuristic find
                                if (sourceProject) originalProjectName = sourceProject.name;
                            } else {
                                const currentProj = getCurrentProject();
                                if (currentProj) originalProjectName = currentProj.name;
                            }
                            if (clickedTask) openModal(clickedTask, originalProjectName);
                        });

                        if (monthCellsElements[startOffsetInWindow]) {
                            monthCellsElements[startOffsetInWindow].appendChild(taskBar);
                        }
                    });
                    ganttGrid.appendChild(row);
                });
            }

            // --- Event Listeners for Navigation ---
            prevMonthBtn.addEventListener('click', () => {
                if (currentStartMonthIndex > 0) {
                    currentStartMonthIndex--;
                    renderCurrentView();
                }
            });

            nextMonthBtn.addEventListener('click', () => {
                currentStartMonthIndex++;
                renderCurrentView();
            });
            
            // --- Event Listeners for Zoom ---
            zoomOutBtn.addEventListener('click', () => {
                if (visibleMonthsCount > minVisibleMonths) {
                    const oldCenterIndex = currentStartMonthIndex + Math.floor(visibleMonthsCount / 2);
                    visibleMonthsCount = Math.max(minVisibleMonths, visibleMonthsCount - 2); // Zoom out by 2 months
                    currentStartMonthIndex = oldCenterIndex - Math.floor(visibleMonthsCount / 2);
                    currentStartMonthIndex = Math.max(0, currentStartMonthIndex); // Boundary check start
                    renderCurrentView();
                }
            });

            zoomInBtn.addEventListener('click', () => {
                const maxPossible = maxVisibleMonths; // Only limited by max zoom level
                if (visibleMonthsCount < maxPossible) {
                     const oldCenterIndex = currentStartMonthIndex + Math.floor(visibleMonthsCount / 2);
                    visibleMonthsCount = Math.min(maxPossible, visibleMonthsCount + 2); // Zoom in by 2 months
                    currentStartMonthIndex = oldCenterIndex - Math.floor(visibleMonthsCount / 2);
                    currentStartMonthIndex = Math.max(0, currentStartMonthIndex); // Boundary check start
                    renderCurrentView();
                }
            });
            
            // Initial Load
            initializeView(); // Calls renderCurrentView now

            // --- Helper function to get month name and short year for header ---
            function getMonthHeaderLabel(monthOffset) { // monthOffset from currentStartMonthIndex
                const actualMonthIndex = currentStartMonthIndex + monthOffset;
                const year = startYear + Math.floor(actualMonthIndex / 12);
                const monthName = monthNames[actualMonthIndex % 12];
                return `${monthName} '${String(year).slice(-2)}`;
            }

            function closeMemberModal() {
                memberModal.style.display = 'none';
            }

            // Add event listeners for member modal
            closeMemberModalButton.onclick = closeMemberModal;
            // Reuse window click/keydown from task modal logic, but check if member modal is open
            const originalWindowOnClick = window.onclick;
            window.onclick = function(event) {
                if (event.target == memberModal) {
                    closeMemberModal();
                } else if (originalWindowOnClick) {
                    originalWindowOnClick(event); // Call original handler (for task modal)
                }
            }
            const originalWindowOnKeydown = window.onkeydown;
            window.onkeydown = function(event) {
                if (event.key === "Escape") {
                    if (memberModal.style.display === 'block') {
                        closeMemberModal();
                    } else if (taskModal.style.display === 'block' && originalWindowOnKeydown) {
                         originalWindowOnKeydown(event); // Call original handler (for task modal escape)
                    }
                }
            }
            
            function openMemberModal(memberId) {
                const member = teamMembers.find(m => m.id === memberId);
                const project = getCurrentProject();
                if (!member || !project) return;

                const now = new Date();
                const currentRealYear = now.getFullYear();
                const currentRealMonthIndex = now.getMonth();
                const currentAbsoluteMonthIndex = (currentRealYear - startYear) * 12 + currentRealMonthIndex;

                const assignedTasks = project.tasks.filter(task => task.memberIds.includes(member.id));
                
                const overdueCount = assignedTasks.filter(task => 
                    !task.completed && dateToMonthIndex(task.endDate) < currentAbsoluteMonthIndex
                ).length;
                
                const upcomingCount = assignedTasks.filter(task => 
                     !task.completed && dateToMonthIndex(task.endDate) >= currentAbsoluteMonthIndex
                ).length;

                modalMemberName.textContent = member.name;
                modalMemberRole.textContent = member.role || 'N/A';
                modalMemberOverdue.textContent = overdueCount;
                modalMemberUpcoming.textContent = upcomingCount;

                // Populate task list
                memberTaskList.innerHTML = ''; // Clear previous list
                if (assignedTasks.length > 0) {
                    assignedTasks.sort((a, b) => dateToMonthIndex(a.endDate) - dateToMonthIndex(b.endDate)).forEach(task => {
                        const li = document.createElement('li');
                        
                        const taskNameSpan = document.createElement('span');
                        taskNameSpan.textContent = task.name;
                        li.appendChild(taskNameSpan);
                        
                        // Add status indicator to list item
                        const statusSpan = document.createElement('span');
                        statusSpan.classList.add('task-detail-status');
                        const isOverdue = !task.completed && dateToMonthIndex(task.endDate) < currentAbsoluteMonthIndex;
                        if (task.completed) {
                            statusSpan.textContent = "Completed";
                            statusSpan.classList.add('completed');
                        } else if (isOverdue) {
                            statusSpan.textContent = "Overdue";
                            statusSpan.classList.add('overdue');
                        } else {
                            statusSpan.textContent = "In Progress";
                            statusSpan.classList.add('in-progress');
                        }
                        li.appendChild(statusSpan);

                        memberTaskList.appendChild(li);
                    });
                } else {
                    const li = document.createElement('li');
                    li.textContent = 'No assigned tasks in this project.';
                    memberTaskList.appendChild(li);
                }
                
                memberModal.style.display = 'block';
            }

            function closeMonthSummaryModal() {
                monthSummaryModal.style.display = 'none';
            }
            
            function openMonthSummaryModal(monthIndex) {
                const project = getCurrentProject();
                if (!project) return;

                const now = new Date();
                const currentRealYear = now.getFullYear();
                const currentRealMonthIndex = now.getMonth();
                const currentAbsoluteMonthIndex = (currentRealYear - startYear) * 12 + currentRealMonthIndex;

                modalMonthSummaryMonthYear.textContent = getFormattedMonthYear(monthIndex);
                
                // Populate Deadlines for the current project
                const projectDeadlinesForModal = project.deadlines || [];
                const deadlinesInMonth = projectDeadlinesForModal.filter(d => dateToMonthIndex(d.date) === monthIndex);
                monthSummaryDeadlineList.innerHTML = '';
                if (deadlinesInMonth.length > 0) {
                    deadlinesInMonth.forEach(deadline => {
                        const li = document.createElement('li');
                        li.textContent = `${deadline.name}${deadline.exactDate ? ' ('+deadline.exactDate+')' : ''}`;
                        monthSummaryDeadlineList.appendChild(li);
                    });
                } else {
                    monthSummaryDeadlineList.innerHTML = '<li>No deadlines this month.</li>';
                }

                // Populate Tasks
                const tasksInMonth = project.tasks.filter(task => 
                    dateToMonthIndex(task.startDate) <= monthIndex && dateToMonthIndex(task.endDate) >= monthIndex
                );
                monthSummaryTaskList.innerHTML = '';
                if (tasksInMonth.length > 0) {
                     tasksInMonth.sort((a, b) => dateToMonthIndex(a.startDate) - dateToMonthIndex(b.startDate)).forEach(task => {
                        const li = document.createElement('li');
                        // Find all assignees for the task
                        const assignees = teamMembers.filter(m => task.memberIds.includes(m.id));
                        const assigneeNames = assignees.map(m => m.name).join(', ') || 'Unknown';
                        
                        const taskNameSpan = document.createElement('span');
                        taskNameSpan.textContent = `${task.name} (${assigneeNames})`; // Show all assignees
                        li.appendChild(taskNameSpan);
                        
                        const statusSpan = document.createElement('span');
                        statusSpan.classList.add('task-detail-status');
                        const isOverdue = !task.completed && dateToMonthIndex(task.endDate) < currentAbsoluteMonthIndex;
                        if (task.completed) {
                            statusSpan.textContent = "Completed";
                            statusSpan.classList.add('completed');
                        } else if (isOverdue) {
                            statusSpan.textContent = "Overdue";
                            statusSpan.classList.add('overdue');
                        } else {
                            statusSpan.textContent = "In Progress";
                            statusSpan.classList.add('in-progress');
                        }
                        li.appendChild(statusSpan);

                        monthSummaryTaskList.appendChild(li);
                    });
                } else {
                     monthSummaryTaskList.innerHTML = '<li>No tasks active this month for ${project.name}.</li>';
                }

                monthSummaryModal.style.display = 'block';
            }

            // --- Modal Event Listeners Setup ---
            // Setup common modal closing listeners once
            function setupModalClosers() {
                console.log("Setting up modal closers...");
                // Close buttons
                closeModalButton.onclick = () => { console.log('Close task modal button clicked'); closeModal(); }; 
                closeMemberModalButton.onclick = () => { console.log('Close member modal button clicked'); closeMemberModal(); };
                closeMonthSummaryModalButton.onclick = () => { console.log('Close month summary modal button clicked'); closeMonthSummaryModal(); };

                // Window click
                 window.onclick = function(event) {
                    console.log('Window clicked', event.target);
                    if (event.target == taskModal) { console.log('Closing task modal via backdrop'); closeModal(); }
                    if (event.target == memberModal) { console.log('Closing member modal via backdrop'); closeMemberModal(); }
                    if (event.target == monthSummaryModal) { console.log('Closing month summary modal via backdrop'); closeMonthSummaryModal(); }
                 }

                 // Escape key
                 window.onkeydown = function(event) {
                    if (event.key === "Escape") {
                        console.log('Escape key pressed');
                        if (taskModal.style.display === 'block') { console.log('Closing task modal via Escape'); closeModal(); }
                        if (memberModal.style.display === 'block') { console.log('Closing member modal via Escape'); closeMemberModal(); }
                        if (monthSummaryModal.style.display === 'block') { console.log('Closing month summary modal via Escape'); closeMonthSummaryModal(); }
                    }
                 }
            }
            setupModalClosers(); // Call setup

            // --- Placeholder for Board View Rendering ---
            function renderBoard() {
                const project = getCurrentProject();
                if (!project) {
                    boardContainer.innerHTML = '<p style="padding: 20px; text-align: center;">Select a project.</p>';
                    return; 
                }
                // Basic placeholder for now - REMOVE THIS
                // boardContainer.innerHTML = `<h3 style="text-align: center; color: #bb86fc;">Board View for ${project.name}</h3><p style="text-align: center;">(Coming Soon)</p>`;
                
                boardContainer.innerHTML = ''; // Clear previous content

                const tasks = project.tasks;
                const now = new Date();
                const currentRealYear = now.getFullYear();
                const currentRealMonthIndex = now.getMonth();
                const currentAbsoluteMonthIndex = (currentRealYear - startYear) * 12 + currentRealMonthIndex;

                // --- Filter Tasks ---
                const overdueTasks = tasks.filter(task => 
                    !task.completed && 
                    dateToMonthIndex(task.endDate) < currentAbsoluteMonthIndex
                ).sort((a, b) => dateToMonthIndex(a.endDate) - dateToMonthIndex(b.endDate)); // Sort overdue by end date

                const thisMonthTasks = tasks.filter(task => 
                    !task.completed && 
                    dateToMonthIndex(task.startDate) <= currentAbsoluteMonthIndex && 
                    dateToMonthIndex(task.endDate) >= currentAbsoluteMonthIndex
                ).sort((a, b) => dateToMonthIndex(a.endDate) - dateToMonthIndex(b.endDate)); // Sort by end date

                // --- Render "Overdue Tasks" Section (if any) ---
                if (overdueTasks.length > 0) {
                    const overdueSection = document.createElement('div');
                    overdueSection.classList.add('board-section', 'overdue-section');
                    overdueSection.innerHTML = `<h3>ðŸš¨ Overdue Tasks (${overdueTasks.length})</h3>`;
                    const overdueList = document.createElement('ul');
                    overdueList.classList.add('board-task-list');
                    overdueTasks.forEach(task => {
                        overdueList.appendChild(createTaskCard(task, 'end')); // Show end date for context
                    });
                    overdueSection.appendChild(overdueList);
                    boardContainer.appendChild(overdueSection); // Add to the container
                }

                // --- Render "This Month" Section ---
                const thisMonthSection = document.createElement('div');
                thisMonthSection.classList.add('board-section');
                const currentMonthLabel = getFormattedMonthYear(currentAbsoluteMonthIndex);
                thisMonthSection.innerHTML = `<h3>Active This Month <span class="current-month-label">(${currentMonthLabel})</span></h3>`;
                const thisMonthList = document.createElement('ul');
                thisMonthList.classList.add('board-task-list');
                
                if (thisMonthTasks.length > 0) {
                    thisMonthTasks.forEach(task => {
                        thisMonthList.appendChild(createTaskCard(task, 'end'));
                    });
                } else {
                    thisMonthList.innerHTML = '<li style="color: #aaa; font-style: italic;">No tasks active this month.</li>';
                }
                thisMonthSection.appendChild(thisMonthList);
                boardContainer.appendChild(thisMonthSection);

                // --- Render "Upcoming Tasks" Section ---
                const upcomingSection = document.createElement('div');
                upcomingSection.classList.add('board-section');
                upcomingSection.innerHTML = `<h3>Upcoming Tasks</h3>`;
                const upcomingList = document.createElement('ul');
                upcomingList.id = 'upcomingTaskList'; // ID for easy update
                upcomingList.classList.add('board-task-list');
                
                const paginationControls = document.createElement('div');
                paginationControls.id = 'upcomingPaginationControls'; // ID for easy update
                paginationControls.classList.add('pagination-controls');

                if (thisMonthTasks.length > 0) {
                    upcomingSection.appendChild(upcomingList);
                    upcomingSection.appendChild(paginationControls);
                    renderUpcomingTasksPage(thisMonthTasks, upcomingList, paginationControls); // Initial render
                } else {
                    upcomingList.innerHTML = '<li style="color: #aaa; font-style: italic;">No upcoming tasks scheduled.</li>';
                    upcomingSection.appendChild(upcomingList); // Still add the list to show the message
                }
                boardContainer.appendChild(upcomingSection);
            }

            // --- Helper to Create Task Card Element ---
            function createTaskCard(task, dateTypeToShow = 'start') {
                const li = document.createElement('li');
                li.classList.add('board-task-card');

                // Use assignee color logic if desired, or a default
                const assignees = teamMembers.filter(m => task.memberIds.includes(m.id));
                const assigneeNames = assignees.map(m => m.name).join(', ') || 'Unassigned';
                // Example: Use color of first assignee if exists
                if (assignees.length > 0) {
                    const memberIndex = teamMembers.findIndex(m => m.id === assignees[0].id);
                     if (memberIndex !== -1) {
                         const colorIndex = memberIndex % taskColorPalette.length;
                         li.style.borderLeftColor = taskColorPalette[colorIndex];
                     }
                }

                let dateInfo = '';
                if (dateTypeToShow === 'start') {
                    dateInfo = `Starts: ${getFormattedMonthYear(dateToMonthIndex(task.startDate))}`;
                } else if (dateTypeToShow === 'end') {
                    dateInfo = `Ends: ${getFormattedMonthYear(dateToMonthIndex(task.endDate))}`;
                }

                li.innerHTML = `
                    <strong>${task.name}</strong>
                    <div class="assignees">Assignees: ${assigneeNames}</div>
                    <div class="date-info">${dateInfo}</div>
                `;
                 // Add click listener to open task modal (optional but nice)
                 li.style.cursor = 'pointer';
                 li.addEventListener('click', () => {
                    // Find the original project for this task when clicking from board view
                    let originalProjectName = "Unknown Project";
                    const sourceProject = projects.find(p => p.tasks.some(t_orig => t_orig.id === task.id && t_orig.name === task.name)); // Heuristic find
                    if (sourceProject) originalProjectName = sourceProject.name;
                    openModal(task, originalProjectName);
                 }); 

                // Add description if it exists
                if (task.description) {
                    const descriptionDiv = document.createElement('div');
                    descriptionDiv.classList.add('description');
                    descriptionDiv.innerHTML = task.description; // Use innerHTML here
                    descriptionDiv.title = task.description; // Show full description on hover
                    li.appendChild(descriptionDiv);
                }

                return li;
            }

            // --- Upcoming Tasks Pagination Logic ---
            function renderUpcomingTasksPage(upcomingTasks, listElement, controlsElement) {
                listElement.innerHTML = ''; // Clear current page
                controlsElement.innerHTML = ''; // Clear controls

                const totalTasks = upcomingTasks.length;
                if (totalTasks === 0) return; // Should have been handled before calling

                const totalPages = Math.ceil(totalTasks / tasksPerPage);
                // Ensure currentPage is valid
                upcomingTasksCurrentPage = Math.max(1, Math.min(upcomingTasksCurrentPage, totalPages));

                const startIndex = (upcomingTasksCurrentPage - 1) * tasksPerPage;
                const endIndex = startIndex + tasksPerPage;
                const pageTasks = upcomingTasks.slice(startIndex, endIndex);

                pageTasks.forEach(task => {
                    listElement.appendChild(createTaskCard(task, 'start'));
                });

                // Create Pagination Controls
                const prevButton = document.createElement('button');
                prevButton.textContent = 'Previous';
                prevButton.disabled = upcomingTasksCurrentPage === 1;
                prevButton.addEventListener('click', () => {
                    if (upcomingTasksCurrentPage > 1) {
                        upcomingTasksCurrentPage--;
                        renderUpcomingTasksPage(upcomingTasks, listElement, controlsElement); // Re-render
                    }
                });

                const pageInfo = document.createElement('span');
                pageInfo.textContent = `Page ${upcomingTasksCurrentPage} of ${totalPages}`;

                const nextButton = document.createElement('button');
                nextButton.textContent = 'Next';
                nextButton.disabled = upcomingTasksCurrentPage === totalPages;
                nextButton.addEventListener('click', () => {
                    if (upcomingTasksCurrentPage < totalPages) {
                        upcomingTasksCurrentPage++;
                        renderUpcomingTasksPage(upcomingTasks, listElement, controlsElement); // Re-render
                    }
                });

                controlsElement.appendChild(prevButton);
                controlsElement.appendChild(pageInfo);
                controlsElement.appendChild(nextButton);
            }

            // --- View Switching Logic ---
            function switchView(viewType) {
                if (viewType === currentView) return; // Don't re-render if already active

                currentView = viewType;

                // Update button active states
                ganttViewBtn.classList.toggle('active', currentView === 'gantt');
                boardViewBtn.classList.toggle('active', currentView === 'board');

                // Render the newly selected view
                renderCurrentView();
            }

            // Attach listeners to view buttons
            ganttViewBtn.addEventListener('click', () => switchView('gantt'));
            boardViewBtn.addEventListener('click', () => switchView('board'));
        });
    </script>
</body>
</html>
